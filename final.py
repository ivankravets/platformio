import streamlit as st
import yt_dlp
import whisper
import openai
import os

# Load Whisper model for transcription
model = whisper.load_model("base")

# Set your OpenAI API key
openai.api_key = "api-key"

def download_audio(youtube_url):
    ydl_opts = {
        'format': 'bestaudio/best',
        'postprocessors': [{'key': 'FFmpegExtractAudio', 'preferredcodec': 'mp3', 'preferredquality': '192'}],
        'outtmpl': 'audio',
        'noplaylist': True,
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([youtube_url])

def transcribe_audio_with_timestamps(audio_path):
    audio = whisper.load_audio(audio_path)
    audio = whisper.pad_or_trim(audio)
    mel = whisper.log_mel_spectrogram(audio).to(model.device)
    result = model.transcribe(audio_path)

    segments_with_timestamps = []
    for segment in result['segments']:
        start = segment['start']
        end = segment['end']
        text = segment['text']
        segments_with_timestamps.append({
            'start': f"{int(start // 60)}:{int(start % 60):02}",
            'end': f"{int(end // 60)}:{int(end % 60):02}",
            'text': text
        })

    return segments_with_timestamps

def answer_question_with_timestamp(question, segments):
    transcription_with_timestamps = "\n".join([f"[{seg['start']}-{seg['end']}] {seg['text']}" for seg in segments])
    prompt = (
        f"Here is the video transcription with timestamps:\n\n{transcription_with_timestamps}\n\n"
        f"Question: {question}\n\n"
        f"Answer the question based on the transcription. "
        "Provide the most relevant timestamp if available. If not, state that the answer is generated by WaldoGPT."
    )

    try:
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "system", "content": "You are a helpful assistant."},
                      {"role": "user", "content": prompt}],
            max_tokens=300,
        )
        return response['choices'][0]['message']['content']
    except Exception as e:
        return f"An error occurred: {e}"

# Streamlit App Configuration
st.set_page_config(page_title="WaldoGPT: Advanced YouTube Transcription & Q&A", layout="wide")

# Title and subheader
st.markdown("<h1 class='title'>üîç WaldoGPT</h1>", unsafe_allow_html=True)
st.markdown("<h2 class='subheader'>Find hidden insights in your favorite YouTube videos!</h2>", unsafe_allow_html=True)

# Sidebar for YouTube URL
st.sidebar.header("YouTube Video")
youtube_url = st.sidebar.text_input("YouTube URL", placeholder="Enter YouTube URL here")
if st.sidebar.button("Add Link"):
    if youtube_url:
        # Download and process the video
        try:
            download_audio(youtube_url)
            segments = transcribe_audio_with_timestamps('audio.mp3')
            st.session_state.segments = segments
            st.session_state.youtube_link = youtube_url
        except Exception as e:
            st.error(f"An error occurred during processing: {e}")
    else:
        st.warning("Please enter a valid YouTube URL.")


# Chatbot Logic
if 'messages' not in st.session_state:
    st.session_state['messages'] = []

# Layout columns
cols = st.columns([2, 1])
with cols[0]:
    if st.session_state.get('youtube_link'):
        st.video(st.session_state.youtube_link)

    if 'segments' in st.session_state:
        transcription_text = "\n".join([f"[{seg['start']}-{seg['end']}] {seg['text']}" for seg in st.session_state.segments])
        st.sidebar.text_area("Transcription with Timestamps:", transcription_text, height=400)

with cols[1]:    
    # Custom CSS styling
    st.markdown(
    """
    <style>
    body {
        background-color: #F5F5F5;
        font-family: 'Poppins', sans-serif;
        color: #333;
    }
    .title {
        font-size: 52px;
        color: #D32F2F;
        text-align: center;
        margin-bottom: 40px;
        letter-spacing: 2px;
        font-weight: 600;
    }
    .subheader {
        font-size: 26px;
        color: #D32F2F;
        text-align: center;
        margin-bottom: 30px;
    }
    .stButton button {
        background-color: #D32F2F;
        color: white;
        font-size: 18px;
        padding: 10px 20px;
        border: none;
        border-radius: 30px;
        font-family: 'Poppins', sans-serif;
        transition: transform 0.3s ease;
    }
    .stButton button:hover {
        background-color: #F44336;
        transform: scale(1.05);
    }
    .stTextInput>div>input, .stTextArea>div>textarea {
        background-color: #FFFFFF;
        color: #D32F2F;
        border: 2px solid #D32F2F;
        padding: 12px;
        border-radius: 10px;
        font-family: 'Poppins', sans-serif;
    }
    .transcription-area {
        background-color: #FFFFFF;
        color: #333;
        border: 2px solid #D32F2F;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        font-family: 'Poppins', sans-serif;
        margin-bottom: 30px;
    }
    .chat-container {
        height: 300px;
        overflow-y: auto;
        display: flex;
        flex-direction: column-reverse;
        padding: 10px;
        border: 1px solid #D32F2F;
        background-color: #FFFFFF;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .user-message {
        text-align: right;
        color: #D32F2F;
        background-color: #F8D7DA;
        padding: 10px;
        margin: 5px 0;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .bot-message {
        text-align: left;
        color: #D32F2F;
        background-color: #F9F9F9;
        padding: 10px;
        margin: 5px 0;
        border: 2px solid #D32F2F;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    </style>
    """,
    unsafe_allow_html=True
)

    chat_history = "<div class='chat-container'>"
    for message in reversed(st.session_state['messages']):  # Newest at the bottom
        role = message['role']
        content = message['content']
        if role == 'user':
            chat_history += f"<div class='user-message'>User: {content}</div>"
        else:
            chat_history += f"<div class='bot-message'>Bot: {content}</div>"
    chat_history += "</div>"

    st.markdown(chat_history, unsafe_allow_html=True)

    with st.form(key='chat_form', clear_on_submit=True):
        user_input = st.text_input("Type your question here...", placeholder="Ask something...")
        submit_button = st.form_submit_button("Send")

        if submit_button and user_input:
            # Append the user's input immediately to the chat history
            st.session_state['messages'].append({'role': 'user', 'content': user_input})

            # Generate bot response immediately
            if 'segments' in st.session_state:
                bot_response = answer_question_with_timestamp(user_input, st.session_state['segments'])
            else:
                bot_response = "Transcription is not available. Please upload a YouTube link and try again."

            # Append bot response to chat history
            st.session_state['messages'].append({'role': 'bot', 'content': bot_response})

            # Force Streamlit to rerun and display the updated chat history
            st.rerun()
